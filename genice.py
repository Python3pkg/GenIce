#!/usr/bin/nv python

import numpy     as np
import argparse  as ap
import itertools as it
import pairlist  as pl
import digraph   as dg
import random
import sys

def usage(parser):
    parser.print_help()
    #print "usage: genice.py [--rep=x,y,z][--seed=n][--density=d] icephase"
    sys.exit(1)


def readcolumns(file):
    line = file.readline()
    comment = line.find("#")
    line    = line[0:comment]
    return line.split()


def ice_rule(graph):
    if not graph.isZ4():
        print("Error: Some water molecules do not have four HBs.")
        sys.exit(1)
    defects = graph.defects()
    while len(defects)>0:
        graph.purgedefects(defects)
    return graph


def arrange_atoms_TIP4P(coord, graph, cell):
    TIP4P = np.matrix([[0,0,-6.50980307353661025e-03],
                       [0,7.56950327263661182e-02,5.20784245882928820e-02],
                       [0,-7.56950327263661182e-02,5.20784245882928820e-02],
                       [0,0,8.49019692646338919e-03]])   # nm, OHHM
    TIP4P_sites = ["OW","HW1","HW2","MW"]

    atoms = []
    for node in range(graph.number_of_nodes()):
        nei = graph.neighbors(node)
        oh1 = coord[nei[0]] - coord[node]
        oh1 -= np.floor( oh1 / cell + 0.5 ) * cell
        oh2 = coord[nei[1]] - coord[node]
        oh2 -= np.floor( oh2 / cell + 0.5 ) * cell
        y  = oh2 - oh1
        y /= np.linalg.norm(y)
        z = (oh1 + oh2)/2
        z /= np.linalg.norm(z)
        x = np.cross(y,z)
        #print(x,y,z)
        rotmat = np.matrix([x,y,z])
        #print(rotmat)
        rotated = np.dot(TIP4P,rotmat)  #(A^t B^t)^t == B A
        #print(rotated)
        for i in range(len(TIP4P_sites)):
            atoms.append([node+1,"SOL",TIP4P_sites[i],rotated[i,:]+coord[node]])
    return atoms



def format_gro(atoms, cell):
    s = ""
    s += "#Generated by genice.py\n"
    s += "{0}\n".format(len(atoms))
    for i in range(len(atoms)):
        molorder, molname, sitename, position = atoms[i]
        s += "{0:5d}{1:6s}{2:>4s}{3:5d}{4:8.3f}{5:8.3f}{6:8.3f}\n".format(molorder,molname, sitename, i+1,position[0,0],position[0,1],position[0,2])
    s += "    {0} {1} {2}\n".format(cell[0],cell[1],cell[2])
    return s



def format_mdv(atoms, cell):
    s = ""
    s += "-length '({0}, {1}, {2})'\n".format(cell[0]*10,cell[1]*10,cell[2]*10)
    s += "-center 0 0 0\n"
    s += "-fold\n"
    s += "{0}\n".format(len(atoms))
    for i in range(len(atoms)):
        molorder, molname, sitename, position = atoms[i]
        s += "{0:5} {1:9.4f} {2:9.4f} {3:9.4f}\n".format(sitename,position[0,0]*10,position[0,1]*10,position[0,2]*10)
    return s



def replicate(positions, rep, cell):
    repx = positions.copy()
    for m in range(1,rep[0]):
        v = np.array([m*cell[0],0,0])
        repx = np.concatenate((repx,positions+v))
    repy = repx.copy()
    for m in range(1,rep[1]):
        v = np.array([0,m*cell[1],0])
        repy = np.concatenate((repy,repx+v))
    repz = repy.copy()
    for m in range(1,rep[2]):
        v = np.array([0,0,m*lat.cell[2]])
        repz = np.concatenate((repz,repy+v))
    return repz



def replicate_graph(graph, positions, rep, cell):
    repgraph = dg.MyDiGraph()
    for i,j,k in graph.edges_iter(data=True):
        vec = positions[j] - positions[i]
        delta = np.floor( vec / cell + 0.5 ).astype(int)
        #print(i,j,delta)
        for x in range(rep[0]):
            for y in range(rep[1]):
                for z in range(rep[2]):
                    xi = (x + delta[0] + rep[0]) % rep[0]
                    yi = (y + delta[1] + rep[1]) % rep[1]
                    zi = (z + delta[2] + rep[2]) % rep[2]
                    newi = i+nmol*(xi+rep[0]*(yi+rep[1]*zi))
                    newj = j+nmol*(x +rep[0]*(y +rep[1]*z ))
                    if 0 == random.randint(0,1):         #shuffle the bond directions
                        repgraph.add_edge(newi,newj)
                    else:
                        repgraph.add_edge(newj,newi)
    return repgraph

    

def zerodipole(coord, graph_, cell):
    graph = graph_.copy()
    dipole = np.zeros(3)
    for i,j,k in graph.edges_iter(data=True):
        vec = coord[j] - coord[i]
        vec -= np.floor(vec/cell + 0.5) * cell
        dipole += vec
        #add the direction vector as an attribute of the edge
        k["vector"] = vec
    s0 = np.linalg.norm(dipole)
    #In the following calculations, there must be error allowances.
    while s0 > 0.1:
        #print(s0)
        path,pathdipole = graph.homodromiccycle()
        s1 = np.linalg.norm(dipole - 2.0 * pathdipole)
        if s1 - s0 < 1.50:
            #print(s0,s1,dipole,pathdipole)
            #accept the inversion
            for i in range(len(path)-1):
                f = path[i]
                t = path[i+1]
                v = graph.get_edge_data(f,t)["vector"]
                graph.remove_edge(f,t)
                graph.add_edge(t,f,vector=-v)
            s0 = s1
            dipole -= 2.0 * pathdipole

    return graph
    
#make 1h
parser = ap.ArgumentParser(description='')
parser.add_argument('--rep',  '-r', nargs = 3, type=int,   dest='rep',  default=(2,2,2),
                    help='Repeat the unit cell')
parser.add_argument('--dens', '-d', nargs = 1, type=float, dest='dens',
                    help='Specify the density in g/cm3')
parser.add_argument('--seed', '-s', nargs = 1, type=int,   dest='seed', default=(1000,),
                    help='Random seed')
parser.add_argument('--mdview', '-m', action='store_true', dest='mdv',
                    help='Write in MDView format')
parser.add_argument('Type', type=str, nargs=1,
                   help='Crystal type (1c,1h,etc.)')
options = parser.parse_args()

lat = __import__(options.Type[0])
lat.waters = np.fromstring(lat.waters, sep=" ")
lat.waters = lat.waters.reshape((lat.waters.size//3,3))
lat.cell      = np.fromstring(lat.cell, sep=" ")
random.seed(options.seed[0])

pairs = None
bondlen = None
try:
    lines = lat.pairs.split("\n")
    pairs = set()
    for line in lines:
        columns = line.split()
        if len(columns) == 2:
            i,j = [int(x) for x in columns]
            pairs.add((i,j))
except AttributeError:
    pass #print("Graph is not defined.")
try:
    bondlen = lat.bondlen
except AttributeError:
    pass #print("Bond length is not defined.")


#set density
if options.dens is not None:
    lat.density = options.dens[0]
    
mass = 18  #water
NB   = 6.022e23
nmol = lat.waters.shape[0]   #nmol in a unit cell
d    = mass * nmol / (NB*lat.cell[0]*lat.cell[1]*lat.cell[2]*1e-21)
ratio = (d / lat.density)**(1.0/3.0)
lat.waters *= ratio
lat.cell      *= ratio
if bondlen is not None:
    bondlen   *= ratio



#replicate to make a large cell
reppositions = replicate(lat.waters, options.rep, lat.cell)
#print(reppositions)


#if the topology is given, register them as a digraph and label the intersecting ones.
if pairs is not None:
    graph = dg.MyDiGraph()
    graph.register_pairs(pairs)
    graph = replicate_graph(graph, lat.waters, options.rep, lat.cell)
                    
                    

lat.cell *= options.rep


if pairs is None:
    #make bonded pairs
    pairs = pl.pairlist_fine(reppositions, bondlen, lat.cell)
    graph = dg.MyDiGraph()
    graph.register_pairs(pairs)
#    for i,j,k in graph.edges_iter(data=True):
#        print(i+8,j+8)
#else:
#    for i,j,k in graph.edges_iter(data=True):
#        vec = reppositions[j] - reppositions[i]
#        vec -= np.floor( vec / lat.cell + 0.5 ) * lat.cell
#        print(i,j,np.linalg.norm(vec))

    
    
if graph.number_of_edges() != len(reppositions)*2:
    print("Inconsistent number of HBs. {0} {1}".format(graph.number_of_edges(),len(reppositions)*2))
    sys.exit(1)


#make them obey the ice rule
graph = ice_rule(graph)


#Rearrange HBs to purge the total dipole moment.
graph = zerodipole(reppositions, graph, lat.cell)


#arrange molecules
atoms = arrange_atoms_TIP4P(reppositions, graph, lat.cell)


#in GROMACS .gro format
if options.mdv:
    str = format_mdv(atoms, lat.cell)
else:
    str = format_gro(atoms, lat.cell)
print(str,end="")
