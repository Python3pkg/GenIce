#!/usr/bin/nv python

import numpy     as np
import argparse  as ap
import itertools as it
import pairlist  as pl
import digraph   as dg
import random
import sys

def usage(parser):
    parser.print_help()
    #print "usage: genice.py [--rep=x,y,z][--seed=n][--density=d] icephase"
    sys.exit(1)


    
def readcolumns(file):
    line = file.readline()
    comment = line.find("#")
    line    = line[0:comment]
    return line.split()



def LoadComFile(filename):
    file = open(filename)
    density = None
    box     = None
    pos     = None
    while True:
        columns = readcolumns(file)
        if len(columns) > 0:
            if density is None:
                density = float(columns[0])
            elif box is None:
                box = np.array([float(x) for x in columns])
            elif pos is None:
                nmol = int(columns[0])
                pos = None
                count = 0
                while count < nmol:
                    columns = readcolumns(file)
                    if len(columns) >= 3:
                        count += 1
                        X = np.array([float(x) for x in columns[0:3]])
                        if pos is None:
                            pos = X
                        else:
                            pos = np.vstack([pos, X])
                pos.reshape((3,nmol))
                return pos,box,density



def generate_graph(pairs):
    graph = dg.MyDiGraph()
    graph.register_pairs(pairs)
    if not graph.isZ4():
        print("Error: Some water molecules do not have four HBs.")
        sys.exit(1)
    defects = graph.defects()
    while len(defects)>0:
        graph.purgedefects(defects)
    return graph


def arrange_atoms_TIP4P(coord, graph):
    TIP4P = np.matrix([[0,0,-6.50980307353661025e-03],
                       [0,7.56950327263661182e-02,5.20784245882928820e-02],
                       [0,-7.56950327263661182e-02,5.20784245882928820e-02],
                       [0,0,8.49019692646338919e-03]])   # nm, OHHM
    TIP4P_sites = ["OW","HW1","HW2","MW"]

    atoms = []
    for node in range(graph.number_of_nodes()):
        nei = graph.neighbors(node)
        oh1 = coord[nei[0]] - coord[node]
        oh1 -= np.floor( oh1 / cell + 0.5 ) * cell
        oh2 = coord[nei[1]] - coord[node]
        oh2 -= np.floor( oh2 / cell + 0.5 ) * cell
        y  = oh2 - oh1
        y /= np.linalg.norm(y)
        z = (oh1 + oh2)/2
        z /= np.linalg.norm(z)
        x = np.cross(y,z)
        #print(x,y,z)
        rotmat = np.matrix([x,y,z])
        #print(rotmat)
        rotated = np.dot(TIP4P,rotmat)  #(A^t B^t)^t == B A
        #print(rotated)
        for i in range(len(TIP4P_sites)):
            atoms.append([node+1,"SOL",TIP4P_sites[i],rotated[i,:]+coord[i]])
    return atoms



def format_gro(atoms, cell):
    s = ""
    s += "#Generated by genice.py\n"
    s += "{0}\n".format(len(atoms))
    for i in range(len(atoms)):
        molorder, molname, sitename, position = atoms[i]
        s += "{0:5d}{1:6s}{2:>4s}{3:5d}{4:8.3f}{5:8.3f}{6:8.3f}\n".format(molorder,molname, sitename, i+1,position[0,0],position[0,1],position[0,2])
    s += "    {0} {1} {2}\n".format(cell[0],cell[1],cell[2])
    return s


def zerodipole(coord, graph_, cell):
    graph = graph_.copy()
    dipole = np.zeros(3)
    for i,j,k in graph.edges_iter(data=True):
        vec = coord[j] - coord[i]
        vec -= np.floor(vec/cell + 0.5) * cell
        dipole += vec
        #add the direction vector as an attribute of the edge
        k["vector"] = vec
    s0 = np.linalg.norm(dipole)
    #In the following calculations, there must be error allowances.
    while s0 > 0.1:
        #print(s0)
        path,pathdipole = graph.homodromiccycle()
        s1 = np.linalg.norm(dipole - 2.0 * pathdipole)
        if s1 - s0 < 1.50:
            #print(s0,s1,dipole,pathdipole)
            #accept the inversion
            for i in range(len(path)-1):
                f = path[i]
                t = path[i+1]
                v = graph.get_edge_data(f,t)["vector"]
                graph.remove_edge(f,t)
                graph.add_edge(t,f,vector=-v)
            s0 = s1
            dipole -= 2.0 * pathdipole

    return graph
    
#make 1h
parser = ap.ArgumentParser(description='')
parser.add_argument('--rep',  '-r', nargs = 3, type=int,   dest='rep',  default=(1,1,1),
                    help='Repeat the unit cell')
parser.add_argument('--dens', '-d', nargs = 1, type=float, dest='dens',
                    help='Specify the density in g/cm3')
parser.add_argument('--seed', '-s', nargs = 1, type=int,   dest='seed', default=(1000,),
                    help='Random seed')
parser.add_argument('--bond', '-b', nargs = 1, type=float, dest='bond', default=(0.3,),  #nm
                    help='Bond length threshold')
parser.add_argument('Type', type=str, nargs=1,
                   help='Crystal type (1c,1h,etc.)')
options = parser.parse_args()

pos,cell,density = LoadComFile("{0}.com".format(options.Type[0]))
random.seed(options.seed[0])


#set density
if options.dens is not None:
    density = options.dens[0]
    
mass = 18  #water
NB   = 6.022e23
nmol = pos.shape[0]   #nmol in a unit cell
d    = mass * nmol / (NB*cell[0]*cell[1]*cell[2]*1e-21)
ratio = (density * d)**(1.0/3.0)
pos  *= ratio
cell *= ratio

    
#replicate to make a large cell
rep = options.rep
coord = None
for m in it.product(range(rep[0]),range(rep[1]),range(rep[2])):
    mnp = np.array(m)
    shift = pos + cell*mnp
    if coord is None:
        coord = shift
    else:
        coord = np.concatenate((coord,shift))
cell *= rep


#make bonded pairs
pairs = pl.pairlist_fine(coord, options.bond[0], cell)


#make them obey the ice rule
graph = generate_graph(pairs)


#Rearrange HBs to purge the total dipole moment.
graph = zerodipole(coord, graph, cell)


#arrange molecules
atoms = arrange_atoms_TIP4P(coord, graph)


#in GROMACS .gro format
str = format_gro(atoms, cell)
print(str,end="")
