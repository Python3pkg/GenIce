#!/usr/bin/env python3
# -*- python -*-

import sys
sys.path.append('Lattices')
sys.path.append('Molecules')
sys.path.append('lib')

import numpy     as np
import argparse  as ap
import itertools as it
import pairlist  as pl
import digraph   as dg
import random
import math
import rigid



def usage(parser):
    parser.print_help()
    sys.exit(1)



def ice_rule(graph):
    if not graph.isZ4():
        print("Error: Some water molecules do not have four HBs.")
        sys.exit(1)
    defects = graph.defects()
    while len(defects)>0:
        graph.purgedefects(defects)
    if len(graph.defects()) != 0:
        print("Error: Some water molecules do not obey the ice rule.")
        sys.exit(1)
    return graph



def orientations(coord, graph, cell):
    rotmatrices = []
    for node in range(graph.number_of_nodes()):
        nei = graph.neighbors(node)
        oh1 = coord[nei[0]] - coord[node]
        oh1 -= np.floor( oh1 + 0.5 )
        oh1 = np.dot(oh1,cell)                #abs coord
        oh2 = coord[nei[1]] - coord[node]
        oh2 -= np.floor( oh2 + 0.5 )
        oh2 = np.dot(oh2,cell)                #abs coord
        y  = oh2 - oh1
        y /= np.linalg.norm(y)
        z = (oh1 + oh2)/2
        z /= np.linalg.norm(z)
        x = np.cross(y,z)
        rotmat = np.vstack([x,y,z])
        rotmatrices.append(rotmat)
    return rotmatrices



def arrange_atoms(coord, cell, rotmatrices, intra, labels):
    atoms = []
    for node in range(len(coord)):
        abscom = np.dot(coord[node],cell)
        rotated = np.dot(intra,rotmatrices[node])
        for i in range(len(labels)):
            atoms.append([node+1,"SOL",labels[i],rotated[i,:]+abscom])
    return atoms



def format_gro(atoms, cell, celltype):
    s = ""
    s += "#Generated by genice.py\n"
    s += "{0}\n".format(len(atoms))
    for i in range(len(atoms)):
        molorder, molname, sitename, position = atoms[i]
        s += "{0:5d}{1:6s}{2:>4s}{3:5d}{4:8.3f}{5:8.3f}{6:8.3f}\n".format(molorder,molname, sitename, i+1,position[0],position[1],position[2])
    if celltype == "rect":
        s += "    {0} {1} {2}\n".format(cell[0,0],cell[1,1],cell[2,2])
    return s



def format_mdv(atoms, cell, celltype):
    s = ""
    if celltype == "rect":
        s += "-length '({0}, {1}, {2})'\n".format(cell[0,0]*10,cell[1,1]*10,cell[2,2]*10)
    s += "-center 0 0 0\n"
    s += "-fold\n"
    s += "{0}\n".format(len(atoms))
    for i in range(len(atoms)):
        molorder, molname, sitename, position = atoms[i]
        s += "{0:5} {1:9.4f} {2:9.4f} {3:9.4f}\n".format(sitename,position[0]*10,position[1]*10,position[2]*10)
    return s



def format_euler(positions, cell, rotmatrices, celltype):
    s = ""
    if celltype == "rect":
        s += "@BOX3\n"
        s += "{0} {1} {2}\n".format(cell[0,0]*10,cell[1,1]*10,cell[2,2]*10)
    else:
        s += "@BOX9\n"
        for d in range(3):
            s += "{0} {1} {2}\n".format(cell[0,d]*10,cell[1,d]*10,cell[2,d]*10)
    s += "@NX3A\n"
    s += "{0}\n".format(len(positions))
    for i in range(len(positions)):
        position = np.dot(positions[i],cell)*10   #in Angstrom
        euler = rigid.quat2euler(rigid.rotmat2quat(rotmatrices[i]))
        s += "{0:9.4f} {1:9.4f} {2:9.4f}  {3:9.4f} {4:9.4f} {5:9.4f}\n".format(position[0],
                                                                               position[1],
                                                                               position[2],
                                                                               euler[0],
                                                                               euler[1],
                                                                               euler[2])
    return s


def format_quaternion(positions, cell, rotmatrices, celltype):
    s = ""
    if celltype == "rect":
        s += "@BOX3\n"
        s += "{0} {1} {2}\n".format(cell[0,0]*10,cell[1,1]*10,cell[2,2]*10)
    else:
        s += "@BOX9\n"
        for d in range(3):
            s += "{0} {1} {2}\n".format(cell[0,d]*10,cell[1,d]*10,cell[2,d]*10)
    s += "@NX4A\n"
    s += "{0}\n".format(len(positions))
    for i in range(len(positions)):
        position = np.dot(positions[i],cell)*10   #in Angstrom
        quat     = rigid.rotmat2quat(rotmatrices[i])
        s += "{0:9.4f} {1:9.4f} {2:9.4f}  {3:9.4f} {4:9.4f} {5:9.4f} {6:9.4f}\n".format(position[0],
                                                                               position[1],
                                                                               position[2],
                                                                               quat[0],
                                                                               quat[1],
                                                                               quat[2],
                                                                               quat[3])
    return s


def format_digraph(graph, positions):
    s = ""
    s += "@NGPH\n"
    s += "{0}\n".format(len(positions))
    for i,j,k in graph.edges_iter(data=True):
        s += "{0} {1}\n".format(i,j)
    s += "-1 -1\n"
    return s


def replicate(positions, rep):
    repx = positions.copy()
    for m in range(1,rep[0]):
        v = np.array([m,0,0])
        repx = np.concatenate((repx,positions+v))
    repy = repx.copy()
    for m in range(1,rep[1]):
        v = np.array([0,m,0])
        repy = np.concatenate((repy,repx+v))
    repz = repy.copy()
    for m in range(1,rep[2]):
        v = np.array([0,0,m])
        repz = np.concatenate((repz,repy+v))
    return repz / rep



def replicate_graph(graph, positions, rep):
    repgraph = dg.MyDiGraph()
    nmol = positions.shape[0]
    for i,j,k in graph.edges_iter(data=True):
        vec = positions[j] - positions[i]    #positions in the unreplicated cell
        delta = np.floor( vec + 0.5 ).astype(int)
        for x in range(rep[0]):
            for y in range(rep[1]):
                for z in range(rep[2]):
                    xi = (x + delta[0] + rep[0]) % rep[0]
                    yi = (y + delta[1] + rep[1]) % rep[1]
                    zi = (z + delta[2] + rep[2]) % rep[2]
                    newi = i+nmol*(xi+rep[0]*(yi+rep[1]*zi))
                    newj = j+nmol*(x +rep[0]*(y +rep[1]*z ))
                    if 0 == random.randint(0,1):         #shuffle the bond directions
                        repgraph.add_edge(newi,newj)
                    else:
                        repgraph.add_edge(newj,newi)
    return repgraph



def zerodipole(coord, graph_):
    graph = graph_.copy()
    dipole = np.zeros(3)
    for i,j,k in graph.edges_iter(data=True):
        vec = coord[j] - coord[i]
        vec -= np.floor(vec + 0.5)
        dipole += vec
        k["vector"] = vec
    s0 = np.linalg.norm(dipole)
    #In the following calculations, there must be error allowances.
    while s0 > 0.1:
        path,pathdipole = graph.homodromiccycle()
        s1 = np.linalg.norm(dipole - 2.0 * pathdipole)
        if s1 - s0 < 1.50:
            #accept the inversion
            for i in range(len(path)-1):
                f = path[i]
                t = path[i+1]
                v = graph.get_edge_data(f,t)["vector"]
                graph.remove_edge(f,t)
                graph.add_edge(t,f,vector=-v)
            s0 = s1
            dipole -= 2.0 * pathdipole

    return graph


def getoptions():
    parser = ap.ArgumentParser(description='')
    parser.add_argument('--rep',  '-r', nargs = 3, type=int,   dest='rep',  default=(2,2,2),
                        help='Repeat the unit cell in x,y, and z directions. [2,2,2]')
    parser.add_argument('--dens', '-d', nargs = 1, type=float, dest='dens',
                        help='Specify the ice density in g/cm3')
    parser.add_argument('--seed', '-s', nargs = 1, type=int,   dest='seed', default=(1000,),
                        help='Random seed [1000]')
    parser.add_argument('--format', '-f', nargs = 1,           dest='format', default=("gromacs",), metavar="gmeqd",
                        help='Specify file format [g(romacs)|m(dview)|e(uler)|q(uaternion)|d(igraph)]')
    parser.add_argument('--water', '-w', nargs = 1,           dest='water', default=("tip3p",), metavar="model",
                        help='Specify water model.')
    parser.add_argument('--cages', '-c', action='store_true', dest='cages',
                        help='Also output the cage positions. (g and m format only)')
    parser.add_argument('Type', nargs=1,
                       help='Crystal type (1c,1h,etc.)')
    return parser.parse_args()


def main():
    options = getoptions()

    water   = __import__(options.water[0])
    lat     = __import__(options.Type[0])
    lat.waters = np.fromstring(lat.waters, sep=" ")
    lat.waters = lat.waters.reshape((lat.waters.size//3,3))
    #prepare cell transformation matrix
    if lat.celltype == "rect":
        lat.cell = np.fromstring(lat.cell, sep=" ")
        lat.cell = np.diag(lat.cell)
    elif lat.celltype == "monoclinic":
        lat.cell = np.fromstring(lat.cell, sep=" ")
        beta = lat.cell[3] * math.pi / 180.
        lat.cell = np.array(((lat.cell[0]*1.0, lat.cell[1]*0.0, lat.cell[2]*math.cos(beta)),
                             (lat.cell[0]*0.0, lat.cell[1]*1.0, lat.cell[2]*0.0),
                             (lat.cell[0]*0.0, lat.cell[1]*0.0, lat.cell[2]*math.sin(beta))))
        lat.cell = lat.cell.transpose()   #all the vector calculations are done in transposed manner.
    else:
        print("Error: unknown cell type: {0}".format(lat.celltype))
        sys.exit(1)

    #express molecular positions in the coordinate relative to the cell
    if lat.coord == "absolute":
        lat.waters = np.dot(lat.waters,np.linalg.inv(lat.cell),)
        lat.waters = np.array(lat.waters)
    random.seed(options.seed[0])

    #Prearranged network topology information (if available)
    pairs = None
    bondlen = None
    try:
        lines = lat.pairs.split("\n")
        pairs = set()
        for line in lines:
            columns = line.split()
            if len(columns) == 2:
                i,j = [int(x) for x in columns]
                if j<i:
                    i,j = j,i
                pairs.add((i,j))
    except AttributeError:
        pass #print("Graph is not defined.")

    #Bond length threshold
    try:
        bondlen = lat.bondlen
    except AttributeError:
        pass #print("Bond length is not defined.")

    #Prearranged cage positions
    if options.cages:
        try:
            cagetype = []
            cages = []
            for line in lat.cages.split("\n"):
                cols = line.split()
                if len(cols)>0:
                    cagetype.append(cols[0])
                    cages.append([float(x) for x in cols[1:4]])
            cages = np.array(cages)
        except AttributeError:
            cages = np.array([])

    #set density
    if options.dens is not None:
        lat.density = options.dens[0]

    #scale the cell according to the (specified) density
    mass = 18  #water
    NB   = 6.022e23
    nmol = lat.waters.shape[0]        #nmol in a unit cell
    volume = np.linalg.det(lat.cell)  #volume of a unit cell in nm**3
    d    = mass * nmol / (NB*volume*1e-21)
    ratio = (d / lat.density)**(1.0/3.0)
    lat.cell *= ratio
    if bondlen is not None:
        bondlen   *= ratio


    #replicate water molecules and cages to make a repeated cell
    reppositions = replicate(lat.waters, options.rep)
    if options.cages:
        repcages     = replicate(cages,      options.rep)


    #scale the cell
    for d in range(3):
        lat.cell[:,d] *= options.rep[d]

        
    if pairs is None:
        #make bonded pairs according to the pair distance.
        grid = pl.determine_grid(lat.cell, bondlen)
        pairs = pl.pairlist_fine(reppositions, bondlen, lat.cell, grid)
        graph = dg.MyDiGraph()
        graph.register_pairs(pairs)
    #if the topology is given, replicate the edges to make a repeated cell
    else:
        graph = dg.MyDiGraph()
        graph.register_pairs(pairs)
        graph = replicate_graph(graph, lat.waters, options.rep)


                
    #Test
    if graph.number_of_edges() != len(reppositions)*2:
        print("Inconsistent number of HBs.[2] {0} {1}".format(graph.number_of_edges(),len(reppositions)*2))
        sys.exit(1)


    #make them obey the ice rule
    graph = ice_rule(graph)


    #Rearrange HBs to purge the total dipole moment.
    graph = zerodipole(reppositions, graph)


    #In case only the graph is wanted.
    if options.format[0][0] == "d":
        s = format_digraph(graph, reppositions)
        print(s,end="")
        sys.exit(0)


    #determine the orientations of the water molecules based on edge directions.
    rotmatrices = orientations(reppositions, graph, lat.cell)


    #Final output formats
    #For rigid rotors; no atomic information is required.
    if options.format[0][0] == "e":          # NX3A
        s = format_euler(reppositions, lat.cell, rotmatrices, lat.celltype)
    elif options.format[0][0] == "q":        # NX4A
        s = format_quaternion(reppositions, lat.cell, rotmatrices, lat.celltype)
    else:
        #arrange atoms
        atoms = arrange_atoms(reppositions, lat.cell, rotmatrices, water.sites, water.labels)
        if options.cages:
            molidx = atoms[-1][0] + 1
            for i in range(len(cages)):
                xyz = np.dot(cages[i],lat.cell)
                atoms.append([molidx+i,"C"+cagetype[i],"G"+cagetype[i],xyz])
        if options.format[0][0] == "m":      # MDView
            s = format_mdv(atoms, lat.cell, lat.celltype)
        elif options.format[0][0] == "g":    # GROMACS
            s = format_gro(atoms, lat.cell, lat.celltype)



    print(s, end="")



if __name__ == "__main__":
    main()
